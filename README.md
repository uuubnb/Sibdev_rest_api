README
=====================

Этот README документирует и описывает все шаги, необходимые для создания и запуска веб-приложения.


### Задание 1: Рабочее окружение

##### Начнем с рабочего окружения: репозитория, среды разработки и запуска локального сервера. 

Разрабатывать код будем в локальном репозитории, а загружать результаты — в удаленный. Там их будет проверять наставник. Договоримся: при каждой отправке merge request будем указывать номер задания и описывать выполненную работу в описании.
У нас будет стаб — заготовка приложения. С ней и будем работать.

##### Ход работы:

* Склонировать репозиторий проекта себе в рабочую папку.
* В репозитории ответвиться от ветки `master` и создать ветку `feature/#1`.
* Скачать и настроить [PyCharm](https://www.jetbrains.com/pycharm/) по [инструкции](https://docs.google.com/document/d/13G_jjdX4nLDUtsrl7vB2l6YQUNFWFhW0Oi_2yanylXY/).
* Запустить локальный сервер. Как это сделать — описано в Readme стаба.
* Отправить merge request в `master` наставнику.


### Задание 2: Первое Django-приложение

##### Прежде чем приступить к разработке нашего приложения, потренируемся на отвлеченном примере.

У нас заготовлено небольшое тренировочное приложение: `/server/apps/test`.
Оно работает с 2 строками. Для приложения есть API, который позволяет выполнять запросы: GET, POST, PUT, PATCH, DELETE.

Приложение работает на Django Rest Framework (далее — DRF). Мы будем разбираться с этим фреймворком на протяжении всей практики.

Для приложения есть 3 теста, которые оно не проходит. Вот почему:
1) Должно быть можно выполнять только запросы GET, POST;
2) 2-я строка должна генерироваться автоматически;
3) Через POST должно быть достаточно передавать только 1 строку.

В ходе этого задания удовлетворим тесты. Немного теории о каждом.

1) В DRF за применимость методов API отвечают viewsets. Наш `TestViewSet` содержит мало кода и наследует `ModelViewSet`. `ModelViewSet` наследует много миксинов и `GenericViewSet`. Чтобы разрешить только методы GET и POST, нужно как-то изменить наследование `TestViewSet`.

2) С автоматической генерацией помогают `signals`. Сейчас нужный `signal` не срабатывает, как надо. Чтобы срабатывал — нужно немного изменить логику.

3) Чтобы POST принимал только 1 строку — это к `serializer`. У него есть `class Meta`, в котором заданы модель `Test` и параметр `fields = ‘__all__’`. То есть, этот `serializer` работает со всеми полями Test. Параметр можно изменить: `fields = (‘name’, )`. Но тогда GET не вернет второе поле. Поможет следующая строка: `extra_kwargs = {'random_string': {'read_only': True}}`. 

Разобравшись с этим заданием, мы поймем основы DRF и приступим к разработке нашего основного приложения.


